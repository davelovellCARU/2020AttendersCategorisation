---
title: "attendersCategorisation"
author: "Dave Lovell"
date: "26/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library("dplyr")
library("here")
library("magrittr")
library("forcats")
library("purrr")
```
## Some Old Code

```{r someOldCode}
##  black-box reverse engineering the church background categories
## DL 190912

# dir("rdats")

fileInO <- "O:\\WCC\\Learning and Development\\Research\\PROJECT - Portsmouth 2019 onwards\\Strand 1 - Leaders and Attenders Surveys\\Data\\2018 Data Processing\\rdats\\attenders05-190911 fixing ages.rdat"

if(file.exists(fileInO))
{
  oldAttenders = readRDS(fileInO)
  file.copy(fileInO, here::here("data//oldAttenders.rdat"), overwrite = TRUE)
} else {
  message("Acquiring old attenders data locally - O Drive not connected")
  oldAttenders = readRDS(here::here("data/oldAttenders.rdat"))
}

glimpse(oldAttenders)

newAttenders <- readRDS(here::here("data/2020attenders.rdat"))
## Also load the 2020 data
```

For this exercise, we'll only need some of the data

```{r dropBareCols}
# Little bit of implicit renaming for tranche compatibility
# oldAttenders %<>% select(responseType, ageGroup, regularity, transferStatus, transferReason, transferOther, christian, class1, class2
#                          becameHere = becameChristianHere,
#                          statusChild = childStatus,
#                          statusTeen = teenStatus,
#                          statusYoung = youngStatus,
#                          statusAdult = adultStatus)

## Mutate factor levels for consistency
oldAttenders %<>% filter(ageGroup != "under5")
oldAttenders %<>% filter(responseType == "adult")
# oldAttenders %<>% filter(transferReason != "other")
oldAttenders %<>% mutate(churchBackground = transferStatus %>%
                           fct_recode("churched" = "fromChurch", 
                                       "deChurched" = "fromBreak",
                                       "blending" = "twoChurches", 
                                       "nonChurched" = "firstChurch"))
oldAttenders %<>% select(- transferStatus)
oldAttenders %<>%
  select(churchBackground,
         statusChild = childStatus,
         statusTeen = teenStatus,
         statusYoung = youngStatus,
         statusAdult = adultStatus,
         class1)
```

And now a special function which gets the 'funky' church histories removed

```{r removeFunkyHistories}
## This function looks at the life-stage data and flags anything which has an NA _before_ the latest entry (i.e. incomplete data)
determineFunkiness <- function(someData){
  someData %<>% 
    mutate(isFunky = 
             pmap_lgl(list(statusChild, statusTeen, statusYoung, statusAdult),
             ~ {
               if(all(is.na(c(..1, ..2, ..3, ..4)))) NA else { 
               c(..1, ..2, ..3, ..4) %>% 
                 (negate(is.na)) %>% 
                 which %>% 
                 {!(all(. == 1:max(.)))}}}))
  return(someData)
}

oldAttenders %<>% determineFunkiness
oldAttenders %<>% filter(!isFunky)
oldAttenders %<>% select(-isFunky)
```

Okay this might get confusing: first, find all existing permutations. Then, find any permutations which **always** result in the same `class1` designation

```{r permutations}

### Function for determining mode
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

permutations <- 
  oldAttenders %>%
  group_by_at(vars(-class1)) %>% 
  mutate(mode = Mode(class1)) %>% 
  group_by_all %>%
  summarise(n())



permutations %>%
  group_by_at(vars(-`n()`)) %>%
  summarise(total = sum(`n()`)) %>% 
  group_by_at(vars(-total, -class1)) %>% 
  summarise(biggest = max(total),
            percentage = max(total) / sum(total) * 100) -> decisionSummary

  # summarise(class1sAssigned = length(unique(class1)), `n()` = sum(`n()`)) %>% 
  # arrange(class1sAssigned, -`n()`) %>%
  # filter(class1sAssigned == 1) %>% 
  # select(- class1sAssigned) %>% 
  # left_join(oldAttenders, by = c("churchBackground", "statusChild", "statusTeen", "statusYoung", "statusAdult")) %>% 
  # distinct %>% 
  # arrange(-`n()`, class1) %>% 
  # View
```

* Find 'pure' cases
* Find 'edge' cases
* Are these labels wrong? complexNon seems incorrect.
```{r obsolete}
# 
# oldAttenders$class1 %>% is.na %>% sum
# # none, cool
# names(oldAttenders)
# 
# #:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# # Things which feed into 'class1' (heck let's rename that)
# 
# oldAttenders %>% rename(background = "class1",
#                      switchReason = "class2") -> oldAttenders
# 
# # *ahem*
# # Things which feed into 'background' should be:
# # 'transferStatus' and 'transferReason' and '__status'
# 
# #should have done this before:
# oldAttenders %>%
#   mutate(notes = 
#            replace(notes,notes=="",NA)) -> oldAttenders
# 
# 
# oldAttenders %>% 
#   select(background,transferReason,contains("Status"),ageGroup) %>%
#   #mutate(child = ageGroup %in% c("under5","5-10")) %>% 
#   select(-ageGroup) %>%
#   group_by_at(vars(-background)) %>%
#   summarise(itWillWork = length(unique(background))<2,
#             backgrounds = toString(unique(background)),
#             cases = n()) %>% 
#   (function(x){
#     writeLines("How well will this work?")
#     print(table(x["itWillWork"]))
#     writeLines("\nCases which black box modelling will not work for:")
#     return(x)
#   }) %>% 
#   filter(!itWillWork)
```
